=== BEHAVIORAL CONSTRAINTS ===
AGENTIC PROJECT BOOTSTRAP PROMPT (PASTE AT START OF NEW SESSION)

INITIALIZATION — DO NOT MODIFY

You (ChatGPT) are assisting me (Andreas) with a multi-agent LLM framework project.
You must always:

give crisp, critical, focused answers
challenge assumptions
avoid unrequested brainstorming
avoid rambling or revisiting old topics
produce short, accurate, technical responses
not hallucinate missing details
not invent architecture I did not approve

Constraints:
Controller must remain domain-independent.
No structural changes unless I explicitly request them.
All code must remain strict-schema validated.

When I explicitly ask for:
- a Codex prompt, or
- a commit message

You must:
- return exactly ONE code block per requested artifact
- use plain triple backticks ``` … ```
- include no prose, explanation, or commentary outside the code block
- not combine multiple artifacts in a single code block
- not infer that I want Codex prompts or commit messages unless I explicitly ask

Your role:
Keep critiques strong and eliminate fluff.
Ask clarifying questions when anything is ambiguous.
Prefer surgical patches over large rewrites.
Never assume brainstorming unless I explicitly say “brainstorm.”

END OF BOOTSTRAP PROMPT

=== PROJECT SNAPSHOT ===

===== FILE: src/domain/document_writer/intent/__init__.py =====

from domain.document_writer.intent.types import (
    IntentEnvelope,
    StructuralIntent,
    GlobalSemanticConstraints,
    StylisticPreferences,
)
from domain.document_writer.intent.yaml_loader import load_intent_from_yaml, load_intent_from_file
from domain.document_writer.intent.controller import (
    TextIntentController,
    make_text_intent_controller,
    TextIntentInput,
)

__all__ = [
    "IntentEnvelope",
    "StructuralIntent",
    "GlobalSemanticConstraints",
    "StylisticPreferences",
    "load_intent_from_yaml",
    "load_intent_from_file",
    "TextIntentController",
    "make_text_intent_controller",
    "TextIntentInput",
]

===== FILE: src/domain/document_writer/intent/controller.py =====

from dataclasses import dataclass
import hashlib

from agentic.agents.openai import OpenAIAgent
from agentic.logging_config import get_logger
from agentic.protocols import AgentProtocol
from pydantic import BaseModel

from domain.document_writer.intent.types import IntentEnvelope

logger = get_logger("intent.adapter")

PROMPT_INTENT = """ROLE:
You are the Text → Intent adapter. You extract user intent signals into a structured IntentEnvelope.

INPUT:
{
  "text": "<raw user text>"
}

OUTPUT (STRICT JSON, IntentEnvelope fields only):
{
  "structural_intent": {
    "document_goal": string | null,
    "audience": string | null,
    "tone": string | null,
    "required_sections": [string, ...],
    "forbidden_sections": [string, ...]
  },
  "semantic_constraints": {
    "must_include": [string, ...],
    "must_avoid": [string, ...],
    "required_mentions": [string, ...]
  },
  "stylistic_preferences": {
    "humor_level": string | null,
    "formality": string | null,
    "narrative_voice": string | null
  }
}

RULES:
- Advisory only: do NOT create document structure, tasks, or ordering.
- No planning, no execution, no workflow decisions.
- Do NOT invent section hierarchy or ids; use labels only.
- Unknown fields are forbidden. Strict JSON only.
"""


class TextIntentInput(BaseModel):
    text: str


@dataclass
class TextIntentController:
    """Single-pass projection of raw text into IntentEnvelope; advisory-only."""

    agent: AgentProtocol[TextIntentInput, IntentEnvelope]

    def __call__(self, text: str) -> IntentEnvelope:
        input_model = TextIntentInput(text=text)
        raw = self.agent(input_model.model_dump_json())
        result = IntentEnvelope.model_validate_json(raw)
        logger.info(
            "intent_adapter_call",
            extra={
                "source": "text-intent-adapter",
                "input_hash": hashlib.sha256(text.encode("utf-8")).hexdigest(),
                "model": getattr(self.agent, "model", ""),
            },
        )
        return result


def make_text_intent_controller(
    *,
    model: str = "gpt-4.1-mini",
) -> TextIntentController:
    base_agent = OpenAIAgent(
        name="TextIntentAdapter",
        model=model,
        system_prompt=PROMPT_INTENT,
        input_schema=TextIntentInput,
        output_schema=IntentEnvelope,
        temperature=0.0,
    )

    class AdapterAgent:
        def __init__(self, agent: OpenAIAgent[TextIntentInput, IntentEnvelope]):
            self._agent = agent
            self.name = agent.name
            self.input_schema = agent.input_schema
            self.output_schema = agent.output_schema
            self.id = agent.id
            self.model = getattr(agent, "model", "")

        def __call__(self, user_input: str) -> str:
            # Validate input before sending
            self.input_schema.model_validate_json(user_input)
            return self._agent(user_input)

    return TextIntentController(agent=AdapterAgent(base_agent))

===== FILE: src/domain/document_writer/intent/text_prompt_refiner.py =====

"""
Text Prompt Refiner Contract

- Input: raw user text (str).
- Output: refined user text (str).
- Transformation is semantic-preserving, non-authoritative, and advisory-only.
- The refiner MUST NOT invent intent or meaning; it only normalizes the supplied text.
- The refiner does NOT plan, execute, extract intent, create structure, or generate documents.
"""
import hashlib

from agentic.agents.openai import OpenAIAgent
from agentic.logging_config import get_logger
from agentic.protocols import AgentProtocol
from pydantic import BaseModel


class TextPromptRefinerInput(BaseModel):
    """Raw user text input for the Text Prompt Refiner; sole, authority-free input."""

    text: str


PROMPT_TEXT_REFINER = """ROLE:
You rewrite raw user text into a clearer version of the same intent.

RULES (DO):
- Preserve meaning exactly; rephrase only to clarify.
- Expose ambiguities explicitly instead of guessing.
- Preserve first-person voice, uncertainty, and tone.

RULES (DO NOT):
- Do NOT add goals, ideas, opinions, or examples.
- Do NOT remove core concerns or resolve ambiguity by guessing.
- Do NOT plan, decide structure, extract intent, or generate articles.
- Do NOT explain concepts or define terminology.
- Do NOT use headings, lists, or structured formats.

OUTPUT:
- Return ONLY refined plain prose of the same intent; no commentary or metadata."""


class TextPromptRefinerController:
    """Single-pass refiner: raw text → clarified text; semantic-preserving and advisory-only."""

    def __init__(self, *, agent: AgentProtocol[TextPromptRefinerInput, str]) -> None:
        self.agent = agent
        self.logger = get_logger("text_prompt_refiner")

    def __call__(self, text: str) -> str:
        input_model = TextPromptRefinerInput(text=text)
        raw = self.agent(input_model.model_dump_json())
        self.logger.info(
            "text_prompt_refiner_call",
            extra={
                "controller": "TextPromptRefinerController",
                "input_hash": hashlib.sha256(text.encode("utf-8")).hexdigest(),
                "model": getattr(self.agent, "model", ""),
            },
        )
        return raw


def make_text_prompt_refiner_controller(
    *,
    model: str = "gpt-4.1-mini",
) -> TextPromptRefinerController:
    base_agent = OpenAIAgent(
        name="TextPromptRefiner",
        model=model,
        system_prompt=PROMPT_TEXT_REFINER,
        input_schema=TextPromptRefinerInput,
        output_schema=None,  # type: ignore[arg-type]
        temperature=0.0,
    )

    class RefinerAgent:
        def __init__(self, agent: OpenAIAgent):
            self._agent = agent
            self.name = agent.name
            self.input_schema = agent.input_schema
            self.output_schema = agent.output_schema
            self.id = agent.id
            self.model = getattr(agent, "model", "")

        def __call__(self, user_input: str) -> str:
            self.input_schema.model_validate_json(user_input)
            resp = self._agent.client.chat.completions.create(
                model=self._agent.model,
                temperature=self._agent.temperature,
                messages=[
                    {"role": "system", "content": self._agent.system_prompt.strip()},
                    {"role": "user", "content": user_input},
                ],
            )
            message = resp.choices[0].message
            return (message.content or "").strip()

    return TextPromptRefinerController(agent=RefinerAgent(base_agent))

===== FILE: src/domain/document_writer/intent/types.py =====

"""
Layer 2 Intent Envelope.

This module captures interpreted user intent in a non-executable, contract-only container.
It is NOT responsible for planning, execution, traversal, or inference. Downstream layers
may project subsets of this data, but this module itself remains passive and domain-agnostic.
"""
from typing import List, Optional

from pydantic import BaseModel, Field


class StructuralIntent(BaseModel):
    """Signals that may influence document structure; not executable instructions."""

    document_goal: Optional[str] = Field(
        default=None, description="High-level goal of the document; not a plan."
    )
    audience: Optional[str] = Field(
        default=None, description="Target audience description; does not imply structure."
    )
    tone: Optional[str] = Field(
        default=None, description="Desired tone (e.g., formal); advisory only."
    )
    required_sections: List[str] = Field(
        default_factory=list,
        description="Section labels the user expects; does not create structure by itself.",
    )
    forbidden_sections: List[str] = Field(
        default_factory=list,
        description="Section labels to avoid; does not delete or reorder structure by itself.",
    )


class GlobalSemanticConstraints(BaseModel):
    """Placement-agnostic constraints; no structural implications."""

    must_include: List[str] = Field(
        default_factory=list,
        description="Concepts or facts that must appear somewhere; no placement implied.",
    )
    must_avoid: List[str] = Field(
        default_factory=list,
        description="Concepts or phrases to exclude globally; no placement implied.",
    )
    required_mentions: List[str] = Field(
        default_factory=list,
        description="Entities or topics to mention; not bound to specific sections.",
    )


class StylisticPreferences(BaseModel):
    """Soft, non-binding stylistic preferences."""

    humor_level: Optional[str] = Field(
        default=None, description="Desired humor level; advisory, non-binding."
    )
    formality: Optional[str] = Field(
        default=None, description="Desired formality level; advisory, non-binding."
    )
    narrative_voice: Optional[str] = Field(
        default=None, description="Preferred narrative voice (e.g., first-person); advisory only."
    )


class IntentEnvelope(BaseModel):
    """Top-level container for user intent; groups signals without interpretation or execution."""

    structural_intent: StructuralIntent = Field(
        default_factory=StructuralIntent,
        description="Potential structural signals; not a plan and not executable.",
    )
    semantic_constraints: GlobalSemanticConstraints = Field(
        default_factory=GlobalSemanticConstraints,
        description="Placement-agnostic constraints; do not imply structure or execution.",
    )
    stylistic_preferences: StylisticPreferences = Field(
        default_factory=StylisticPreferences,
        description="Soft style preferences; advisory only and non-binding.",
    )

===== FILE: src/domain/document_writer/intent/yaml_loader.py =====

"""
YAML → IntentEnvelope transpiler.

This is a thin parser only: it performs no inference, execution, or authority.
"""
from pathlib import Path
import yaml

from domain.document_writer.intent.types import IntentEnvelope


def _ensure_dict(data) -> dict:
    if not isinstance(data, dict):
        raise ValueError("Intent YAML must be a mapping at the top level.")
    return data


def load_intent_from_yaml(yaml_text: str) -> IntentEnvelope:
    """Parse YAML into an IntentEnvelope; relies on schema validation for correctness."""
    parsed = yaml.safe_load(yaml_text)
    data = _ensure_dict(parsed)
    unknown = set(data.keys()) - set(IntentEnvelope.model_fields.keys())
    if unknown:
        raise ValueError(f"Unknown intent keys: {sorted(unknown)}")
    return IntentEnvelope.model_validate(data)


def load_intent_from_file(path: str | Path) -> IntentEnvelope:
    """Load YAML from a file path and parse into an IntentEnvelope."""
    text = Path(path).read_text()
    return load_intent_from_yaml(text)
