Below is a **blunt, engineering-level review** of what objectively needs fixing or tightening. This is **not a redesign** and does **not** assume intent beyond the code.

---

## 1. Supervisor contract violations (highest priority)

### 1.1 Supervisor is not truly “pure executor”

**Problem**

* `Supervisor.__call__` conditionally inspects domain-specific fields (`writer_state`, `content`) and injects them into `WorkerInput`.
* This violates your own stated contract: *Supervisor must remain domain-independent*.

**Why this matters**

* You now have **hidden coupling** between Supervisor and Writer domain.
* This is a structural leak, not just an implementation detail.

**Fix direction**

* Move **all domain-specific input shaping** into:

  * the domain API layer, or
  * a domain-specific adapter before Supervisor invocation.
* Supervisor should treat `WorkerInput` as opaque.

---

### 1.2 Tool handling breaks atomicity guarantees

**Problem**

* Supervisor allows:

  * WORK → TOOL → WORK
* But the contract says: *executes exactly one task per request*.

This is **already two worker executions**.

**Why this matters**

* The supervisor is no longer atomic.
* Trace semantics become ambiguous: one “execution” contains multiple worker calls.

**Fix direction**

* Either:

  * Declare tool re-entry explicitly part of one atomic execution (and document it), **or**
  * Enforce single WORK per call and require the caller to resubmit.

Right now it’s **halfway**.

---

## 2. AnalysisSupervisor vs Supervisor inconsistency

### 2.1 Dispatcher misuse in analysis mode

**Problem**

* `AgentDispatcher` is instantiated with:

  ```python
  workers={}
  critic=None
  ```
* But `AgentDispatcher` is not designed for optional critic usage.

**Why this matters**

* This is type-unsafe and only works because Python allows it.
* It weakens the dispatcher’s invariant guarantees.

**Fix direction**

* Either:

  * Introduce a minimal `PlannerOnlyDispatcher`, or
  * Make `AgentDispatcher` explicitly support `critic=None` via typing and runtime guards.

Right now this is **implicit and fragile**.

---

## 3. Planner abstraction leaks

### 3.1 “Planner” agents that ignore LLM output

**Problem**

* Arithmetic and Sentiment planners:

  * Call the LLM
  * Then **ignore its output**
  * And deterministically construct a `PlannerOutput`

**Why this matters**

* This defeats the semantic meaning of “agent”.
* The planner becomes a deterministic router with an LLM-shaped façade.

**Fix direction**

* Either:

  * Remove LLM usage entirely for those planners, **or**
  * Let the LLM actually emit the plan and validate it.

Current state is misleading and will confuse future maintainers.

---

## 4. State handling inconsistencies

### 4.1 DomainStateProtocol is not uniformly respected

**Problem**

* Some domains:

  * Properly treat state as immutable (`WriterDomainState.update`)
* Others:

  * Barely use state or ignore it entirely.
* Supervisor **does not** apply state updates at all.

**Why this matters**

* There is no single place where:

  * “task accepted → state updated”
* This logic is pushed into CLI loops (writer main), which is error-prone.

**Fix direction**

* Decide **one** of:

  * Supervisor emits events only; caller applies state (then remove state logic from Supervisor entirely), **or**
  * Supervisor applies state updates consistently.

Right now it’s split-brain.

---

## 5. Writer domain is architecturally inconsistent

### 5.1 Writer planner is effectively bypassed

**Problem**

* `domain/writer/main.py` manually constructs `WriterTask`.
* Planner exists but is not actually driving execution.

**Why this matters**

* Violates Planner–Worker–Critic discipline.
* Writer behaves differently from every other domain.

**Fix direction**

* Either:

  * Remove the planner and declare writer “manual task mode”, **or**
  * Route **all** writer tasks through the planner.

Right now it’s neither.

---

### 5.2 Writer critic is a stub masquerading as full critic

**Problem**

* `WriterCriticAgent.__call__`:

  * Accepts almost everything.
  * Ignores most of the detailed prompt.

**Why this matters**

* False sense of correctness.
* You cannot trust ACCEPT signals.

**Fix direction**

* Either:

  * Explicitly mark writer critic as `MVPStubCritic`, **or**
  * Implement actual rule enforcement.

Current naming is misleading.

---

## 6. Type and schema hygiene issues

### 6.1 Widespread `extra="allow"`

**Problem**

* Many schemas allow arbitrary extra fields.
* This undermines your “strict schema” claim.

**Why this matters**

* Invalid planner/worker outputs can silently pass.
* You lose auditability.

**Fix direction**

* Tighten schemas where stability is expected.
* Allow extras **only** where evolution is intentional.

---

### 6.2 Inconsistent `.to_llm()` usage

**Problem**

* Some inputs define `to_llm()`.
* Dispatcher ignores it and uses `model_dump()`.

**Why this matters**

* Dead code paths.
* Confusing boundary semantics.

**Fix direction**

* Pick one:

  * Dispatcher always calls `to_llm()` if present, **or**
  * Remove `to_llm()` entirely.

---

## 7. Dispatcher responsibilities are overloaded

**Problem**

* Dispatcher handles:

  * retries
  * validation
  * routing
* But routing is also embedded in planners and domains.

**Why this matters**

* Ambiguous ownership.
* Hard to reason about failure modes.

**Fix direction**

* Dispatcher should:

  * validate
  * retry
  * execute
* Routing decisions should belong **only** to planners.

Right now this boundary is fuzzy.

---

## 8. Logging and trace semantics

**Problem**

* Trace entries are partially structured, partially ad hoc.
* Some entries omit inputs, some omit outputs.

**Why this matters**

* You cannot reliably replay or audit a run.

**Fix direction**

* Enforce a **single trace event schema**.
* Every state transition should emit:

  * state
  * actor (agent/tool)
  * input
  * output

---

## 9. CLI code leaks orchestration logic

**Problem**

* Writer and document CLIs implement orchestration loops.
* This logic is not reusable or testable.

**Why this matters**

* You are re-implementing control logic per domain.

**Fix direction**

* Extract orchestration loops into explicit application-level controllers.
* Keep CLIs thin.

---

## Bottom line

**What is solid**

* Schema discipline (conceptually)
* Explicit contracts (even if violated)
* Clear separation of planner / worker / critic roles
* Tool registry design

**What must be fixed**

1. Supervisor domain leakage
2. Tool + worker atomicity confusion
3. Writer domain inconsistency
4. Planner façade behavior
5. State update ownership
6. Schema strictness drift

If you want, next we can:

* rank these into a concrete fix order,
* produce a **no-scope-creep repair plan**, or
* write a **Codex execution prompt** to fix a specific subset in one pass.

Say which.
